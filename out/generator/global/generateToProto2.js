"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateToProto = void 0;
function generateToProto() {
    return "\n\n  import { Message, Map as ProtobufMap } from \"google-protobuf\";\n\n  export type FromObject<T extends Message> = (data: AsObject<T>) => T;\n  \n  type MessageConstructor<T extends Message> = new () => T;\n  \n  type AsObject<T extends Message> = ReturnType<T[\"toObject\"]>;\n  \n  type MessageFnReturnValue<\n    T extends Message,\n    Key extends keyof T\n  > = T[Key] extends (...args: unknown[]) => infer R ? R : never;\n  \n  type IsProtobufMap<T> = T extends ProtobufMap<unknown, infer X> ? X : T;\n  \n  type IsMessageOrMessageArray<T> = T extends Array<infer R>\n    ? IsMessageOrMessageArray<R>\n    : T extends Message | undefined\n    ? Exclude<T, undefined>\n    : never;\n  \n  type MessageValue<\n    T extends Message,\n    K extends keyof T\n  > = IsMessageOrMessageArray<IsProtobufMap<MessageFnReturnValue<T, K>>>;\n  \n  type MessageKey<\n    T extends Message,\n    K extends keyof T = keyof T\n  > = K extends `get${string}`\n    ? MessageValue<T, K> extends never\n      ? never\n      : K\n    : never;\n  \n  type Prop<K> = K extends `get${infer R}` ? Uncapitalize<R> : never;\n  \n  type MessageFactories<T extends Message> = {\n    [K in MessageKey<T> as Prop<K>]: FromObject<MessageValue<T, K>>;\n  };\n  \n  type EmptyFactory<T extends Message> = MessageKey<T> extends never ? T : never;\n  type NonEmptyFactory<T extends Message> = MessageKey<T> extends never\n    ? never\n    : T;\n  \n  const recursiveFactories = new WeakMap<\n    MessageConstructor<Message>,\n    MessageFactories<Message>\n  >();\n  \n  const enum PREFIX {\n    SET = \"set\",\n    GET = \"get\",\n    CLEAR = \"clear\",\n  }\n  \n  export function createFromObject<T extends Message>(\n    MessageType: MessageConstructor<EmptyFactory<T>>\n  ): FromObject<T>;\n  export function createFromObject<T extends Message>(\n    MessageType: MessageConstructor<NonEmptyFactory<T>>,\n    factories: MessageFactories<T>\n  ): FromObject<T>;\n  export function createFromObject<T extends Message>(\n    MessageType: MessageConstructor<EmptyFactory<T> | NonEmptyFactory<T>>,\n    factories?: MessageFactories<T>\n  ): FromObject<T> {\n    const allFactories = factories ?? ({} as MessageFactories<T>);\n    const recursiveFactory = recursiveFactories.get(MessageType);\n    if (recursiveFactory && Object.keys(allFactories).length > 0) {\n      Object.assign(recursiveFactory, allFactories);\n      recursiveFactories.delete(MessageType);\n    }\n    return (data: AsObject<T>): T => {\n      const instance = new MessageType();\n      validateMissingProps(instance, data);\n      for (const [prop, value] of Object.entries(\n        filterExtraProps(instance, data)\n      )) {\n        if (Array.isArray(value) && isProtobufMap(instance, prop)) {\n          const mapMethod = getMethod(prop, PREFIX.GET);\n          const map = callMethod(instance, mapMethod) as ProtobufMap<\n            unknown,\n            unknown\n          >;\n          for (const [k, v] of value) {\n            if (!isObject(v, prop)) {\n              map.set(k, v);\n              continue;\n            }\n            validateMissingFactory(allFactories, prop);\n            map.set(k, callMethod(allFactories, prop, v));\n          }\n          continue;\n        }\n        const result = getResult(allFactories, prop, value);\n        validateType(instance, prop, value);\n        const setter = getMethod(prop, PREFIX.SET);\n        callMethod(instance, setter, result);\n      }\n      return instance;\n    };\n  }\n  \n  function getResult<T extends Message>(\n    factories: MessageFactories<T>,\n    prop: string,\n    value: unknown\n  ): unknown {\n    if (Array.isArray(value)) {\n      if (value.length === 0 || !isArrayOfObjects(value, prop)) {\n        return value;\n      }\n      validateMissingFactory(factories, prop);\n      return value.map((child) => callMethod(factories, prop, child));\n    }\n    if (isObject(value, prop)) {\n      validateMissingFactory(factories, prop);\n      return callMethod(factories, prop, value);\n    }\n    return value;\n  }\n  \n  function callMethod<T extends object, R>(\n    obj: T,\n    key: string,\n    value?: unknown\n  ): R {\n    return (obj[key as keyof T] as (value: unknown) => R)(value);\n  }\n  \n  function getProp(key: string, prefix: PREFIX): string {\n    const prop = key.slice(prefix.length);\n    return prop.slice(0, 1).toLowerCase() + prop.slice(1);\n  }\n  \n  function getMethod(prop: string, prefix: PREFIX): string {\n    return `${prefix}${prop[0].toUpperCase()}${prop.slice(1)}`;\n  }\n  \n  function getInstancePropsFromKeys(keys: string[], prefix: PREFIX): string[] {\n    return keys\n      .filter((key) => key.startsWith(prefix))\n      .map((key) => getProp(key, prefix));\n  }\n  \n  function getInstanceProps<T extends Message>(instance: T): string[] {\n    const keys = Object.keys(Object.getPrototypeOf(instance));\n    const setters = getInstancePropsFromKeys(keys, PREFIX.SET);\n    const maps = getInstancePropsFromKeys(keys, PREFIX.CLEAR).filter((prop) =>\n      isProtobufMap(instance, prop)\n    );\n    return [...setters, ...maps];\n  }\n  \n  function isProtobufMap<T extends Message>(instance: T, prop: string): boolean {\n    return (\n      callMethod(instance, getMethod(prop, PREFIX.GET)) instanceof ProtobufMap\n    );\n  }\n  \n  function isOptional<T extends Message>(instance: T, prop: string): boolean {\n    const clearMethod = getMethod(prop, PREFIX.CLEAR);\n    return clearMethod in instance;\n  }\n  \n  function validateMissingProps<T extends Message>(\n    instance: T,\n    data: AsObject<T>\n  ): void {\n    const instanceProps = getInstanceProps(instance);\n    const dataProps = Object.keys(data);\n    for (const prop of instanceProps) {\n      if (!dataProps.includes(prop) && !isOptional(instance, prop)) {\n        throw new Error(`Missing property '${prop}'`);\n      }\n    }\n  }\n  \n  function filterExtraProps<T extends Message>(\n    instance: T,\n    data: AsObject<T>\n  ): AsObject<T> {\n    const instanceProps = getInstanceProps(instance);\n    return Object.fromEntries(\n      Object.entries(data).filter(\n        ([key, value]) => instanceProps.includes(key) && value !== undefined\n      )\n    ) as AsObject<T>;\n  }\n  \n  function validateMissingFactory<T extends Message>(\n    factories: MessageFactories<T>,\n    prop: string\n  ): asserts prop is keyof MessageFactories<T> {\n    if (!(prop in factories)) {\n      throw new Error(`Missing factory for '${prop}'`);\n    }\n  }\n  \n  function isObject(value: unknown, prop: string): boolean {\n    if (value === null) {\n      throw new Error(`Null value for key '${prop}'`);\n    }\n    return typeof value === \"object\";\n  }\n  \n  function isArrayOfObjects(arr: unknown[], prop: string): boolean {\n    if (arr.every((item) => isObject(item, prop))) {\n      return true;\n    }\n    if (arr.every((item) => !isObject(item, prop))) {\n      return false;\n    }\n    throw new Error(`Mixed array for '${prop}'`);\n  }\n  \n  function validateType<T extends Message>(\n    instance: T,\n    prop: string,\n    value: unknown\n  ): void {\n    const getter = getMethod(prop, PREFIX.GET);\n    const instanceValue = callMethod(instance, getter);\n    const expectedType =\n      instanceValue !== undefined ? typeof instanceValue : \"object\";\n    const actualType = typeof value;\n    if (Array.isArray(instanceValue) && !Array.isArray(value)) {\n      throw new Error(\n        `Invalid type for '${prop}' (expected array, got '${actualType}')`\n      );\n    }\n    if (!Array.isArray(instanceValue) && Array.isArray(value)) {\n      throw new Error(\n        `Invalid type for '${prop}' (expected '${expectedType}', got array)`\n      );\n    }\n    if (expectedType !== actualType) {\n      throw new Error(\n        `Invalid type for '${prop}' (expected '${expectedType}', got '${actualType}')`\n      );\n    }\n  }\n  \n  export function createFromObjectRecursive<T extends Message>(\n    MessageType: MessageConstructor<NonEmptyFactory<T>>\n  ): FromObject<T> {\n    const factories = {} as MessageFactories<T>;\n    recursiveFactories.set(MessageType, factories);\n    const propertyDescriptors = getInstanceProps(\n      new MessageType()\n    ).reduce<PropertyDescriptorMap>(\n      (acc, prop) => ({\n        ...acc,\n        [prop]: {\n          get() {\n            validateMissingFactory(factories, prop);\n            return factories[prop];\n          },\n        },\n      }),\n      {}\n    );\n  \n    const dynamicFactories = Object.defineProperties(\n      {},\n      propertyDescriptors\n    ) as MessageFactories<T>;\n    return createFromObject(MessageType, dynamicFactories);\n  }\n  \n";
}
exports.generateToProto = generateToProto;
//# sourceMappingURL=generateToProto2.js.map