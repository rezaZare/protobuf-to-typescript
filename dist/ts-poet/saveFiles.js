var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { promises as fs } from "fs";
import { dirname } from "path";
import { createHash } from "crypto";
/**
 * Saves multiple {@link CodegenFile}s.
 */
export function saveFiles(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { toolName = "ts-poet", directory = "./", files, toStringOpts = {}, } = opts;
        yield Promise.all(files.map((file) => __awaiter(this, void 0, void 0, function* () {
            const path = `${directory}/${file.name}`;
            // We might be writing to a subdirectory, so check this for each file
            yield fs.mkdir(dirname(path), { recursive: true });
            const exists = yield trueIfResolved(fs.access(path));
            if (file.overwrite) {
                if (!file.hash) {
                    // Just write the file w/o the hash hint (i.e. for JSON/etc)
                    yield fs.writeFile(path, contentToString(file, toStringOpts));
                }
                else {
                    // Create a hash of the unformatted option (to avoid the cost of formatting)
                    const hash = sha1(contentToString(file, Object.assign(Object.assign({}, toStringOpts), { format: false })));
                    if (exists) {
                        const existing = (yield fs.readFile(path)).toString();
                        const match = existing.match(/\(hash=([0-9a-z]+)\.([0-9]+)\)/);
                        // console.log({ existing: existing.length, hash: match?.[1], length: match?.[2] });
                        //
                        // If the pre-format hash matches _and_ our post-format file length has not changed,
                        // just skip formatting + outputting this file.
                        //
                        // We use the length check to catch programmer's making manual changes to the
                        // generated file that, b/c it is changing to the post-format text, won't get
                        // caught by our pre-format hash check.
                        if (match &&
                            match[1] === hash &&
                            String(existing.length) === match[2])
                            return;
                    }
                    // Now write the post-format output, but tagged with the pre-format hash
                    const formatted = contentToString(file, toStringOpts);
                    const prefix = `// Generated by ${toolName} (hash=${hash}.`;
                    const suffix = `)\n` + formatted;
                    const initialLength = prefix.length + suffix.length;
                    const lengthLength = String(initialLength).length;
                    // If initialLength is 998, and lengthLength is 3, then newLength will be 1001 and need 4 digits
                    const pad = lengthLength !== String(initialLength + lengthLength).length
                        ? 1
                        : 0;
                    yield fs.writeFile(path, prefix + String(initialLength + lengthLength + pad) + suffix);
                }
            }
            else if (!exists) {
                yield fs.writeFile(path, contentToString(file, {}));
            }
        })));
    });
}
function contentToString(file, toStringOpts) {
    var _a;
    if (typeof file.contents === "string") {
        return file.contents;
    }
    // Do a lazy/by-hand deep merge of toStringOpts and file.toStringOpts
    return file.contents.toString(Object.assign(Object.assign(Object.assign({ path: file.name }, toStringOpts), file.toStringOpts), { dprintOptions: Object.assign(Object.assign({}, toStringOpts.dprintOptions), (_a = file.toStringOpts) === null || _a === void 0 ? void 0 : _a.dprintOptions) }));
}
// We purposefully use sha1 for speed b/c this isn't for crypto/auth
function sha1(content) {
    const sum = createHash("sha1");
    sum.update(content);
    return sum.digest("hex").substring(0, 6);
}
/** Returns true if `p` is resolved, otherwise false if it is rejected. */
function trueIfResolved(p) {
    return __awaiter(this, void 0, void 0, function* () {
        return p.then(() => true, () => false);
    });
}
//# sourceMappingURL=saveFiles.js.map